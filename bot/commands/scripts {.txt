"scripts": {
  "start": "node bot.js",
  "test": "echo \"Error: no test specified\" && exit 1"
},

/**
 * Telegram Trade Bot
 * -------------------
 * This bot provides basic functionalities for logging trades,
 * getting trade statistics, suggesting trades (placeholder logic),
 * and integrating with UI.Vision RPA for automated trading actions on Pocket Option.
 * It uses Telegraf for Telegram bot interactions.
 */

// === MODULE IMPORTS ===
const { Telegraf } = require('telegraf'); // Telegram Bot API framework
const fs = require('fs'); // File system module for reading/writing files
const path = require('path'); // Path module for working with file and directory paths
const axios = require('axios'); // Promise-based HTTP client for making requests to UI.Vision
require('dotenv').config(); // Loads environment variables from a .env file into process.env

// === CONFIGURATION ===
// Retrieve sensitive information and configuration from environment variables
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN; // Your Telegram bot's API token
const DEFAULT_TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID; // Default chat ID for background alerts

// UI.Vision RPA Configuration (ensure these are set in your .env file)
const UI_VISION_URL = process.env.UI_VISION_URL; // e.g., http://localhost:3333/api/macros/execute
const UI_VISION_MACRO_NAME = process.env.UI_VISION_MACRO_NAME; // e.g., PocketOptionTrade
// This JSON string defines the parameters expected by your UI.Vision macro.
// Ensure it includes all variables used in your macro (symbol, direction, amount, expiry, username, password).
const UI_VISION_MACRO_PARAMS_JSON = process.env.UI_VISION_MACRO_PARAMS_JSON;

// Pocket Option Credentials (ensure these are set in your .env file)
const POCKET_OPTION_USERNAME = process.env.POCKET_OPTION_USERNAME;
const POCKET_OPTION_PASSWORD = process.env.POCKET_OPTION_PASSWORD;

// Validate essential environment variables
if (!TELEGRAM_BOT_TOKEN) {
  console.error('‚ùå ERROR: TELEGRAM_BOT_TOKEN is not defined in your .env file.');
  process.exit(1); // Exit if the bot token is missing
}
if (!UI_VISION_URL || !UI_VISION_MACRO_NAME || !UI_VISION_MACRO_PARAMS_JSON) {
  console.error('‚ùå ERROR: UI.Vision configuration (UI_VISION_URL, UI_VISION_MACRO_NAME, UI_VISION_MACRO_PARAMS_JSON) is incomplete in your .env file.');
  // Do not exit here, as the bot might still function for logging, but UI.Vision calls will fail.
}
if (!POCKET_OPTION_USERNAME || !POCKET_OPTION_PASSWORD) {
  console.warn('‚ö†Ô∏è WARNING: Pocket Option credentials (POCKET_OPTION_USERNAME, POCKET_OPTION_PASSWORD) are not fully defined in your .env file. UI.Vision trades might fail.');
}


// Initialize the Telegraf bot
const bot = new Telegraf(TELEGRAM_BOT_TOKEN);

// Define path for the trade log file
const TRADE_LOG_DIR = path.join(__dirname, 'logs');
const TRADE_LOG_PATH = path.join(TRADE_LOG_DIR, 'trade-log.json');

// Ensure the logs directory exists
try {
  if (!fs.existsSync(TRADE_LOG_DIR)) {
    fs.mkdirSync(TRADE_LOG_DIR);
    console.log(`‚úÖ Created logs directory: ${TRADE_LOG_DIR}`);
  }
} catch (error) {
  console.error(`‚ùå Error creating logs directory: ${error.message}`);
  process.exit(1); // Exit if directory cannot be created
}

// Ensure the trade log file exists and is initialized as an empty array
try {
  if (!fs.existsSync(TRADE_LOG_PATH)) {
    fs.writeFileSync(TRADE_LOG_PATH, JSON.stringify([]));
    console.log(`‚úÖ Initialized trade log file: ${TRADE_LOG_PATH}`);
  }
} catch (error) {
  console.error(`‚ùå Error initializing trade log file: ${error.message}`);
  process.exit(1); // Exit if file cannot be created
}

// === UTILITY FUNCTIONS ===

/**
 * Reads the trade log from the JSON file.
 * @returns {Array<Object>} An array of trade objects.
 */
function readTradeLog() {
  try {
    const data = fs.readFileSync(TRADE_LOG_PATH, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    console.error(`‚ùå Error reading trade log: ${error.message}`);
    return []; // Return empty array on error
  }
}

/**
 * Writes the trade log to the JSON file.
 * @param {Array<Object>} trades - The array of trade objects to write.
 */
function writeTradeLog(trades) {
  try {
    // Keep only the last 20 trades to prevent the log from growing too large
    const recentTrades = trades.slice(-20);
    fs.writeFileSync(TRADE_LOG_PATH, JSON.stringify(recentTrades, null, 2));
  } catch (error) {
    console.error(`‚ùå Error writing trade log: ${error.message}`);
  }
}

/**
 * Logs a new trade entry.
 * @param {string} pair - The trading pair (e.g., 'EURUSD').
 * @param {string} direction - 'buy' or 'sell'.
 * @param {number} amount - The trade amount.
 * @param {number} expiry - The expiry time in minutes.
 * @param {string|null} result - 'win', 'loss', or null if pending.
 */
function logTrade(pair, direction, amount, expiry, result = null) {
  const trades = readTradeLog();
  trades.push({
    pair,
    direction,
    amount,
    expiry,
    result,
    timestamp: new Date().toISOString(),
  });
  writeTradeLog(trades);
  console.log(`üìù Logged trade: ${pair} ${direction.toUpperCase()} $${amount} ${expiry}m`);
}

/**
 * Retrieves trade statistics (last 3 trades and win rate).
 * @returns {Object} An object containing last 3 trades and win rate.
 */
function getTradeStats() {
  const trades = readTradeLog();
  const last3 = trades.slice(-3); // Get the last 3 trades
  const wins = trades.filter(t => t.result === 'win').length;
  const losses = trades.filter(t => t.result === 'loss').length;
  const total = wins + losses;
  const winRate = total ? ((wins / total) * 100).toFixed(1) + '%' : 'N/A';
  return { last3, winRate };
}

/**
 * Placeholder function for analysis and trade suggestions.
 * In a real scenario, this would involve fetching real-time data,
 * applying indicators, and making decisions.
 * @returns {string} A formatted string of trade suggestions.
 */
function analyzeAndSuggest() {
  const pairs = ['EURUSD', 'GBPUSD', 'USDJPY', 'AUDUSD', 'NZDUSD']; // Expand as needed
  const suggestions = pairs.map(pair => {
    // Simple random decision for demonstration
    const decision = Math.random() > 0.5 ? 'buy' : 'sell';
    const confidence = Math.floor(60 + Math.random() * 40); // Random confidence between 60-99%
    return `‚Ä¢ ${pair}: ${decision.toUpperCase()} (Confidence: ${confidence}%)`;
  });
  return suggestions.join('\n');
}

/**
 * Placeholder function for learning from past trades.
 * In a real scenario, this would update a model or adjust parameters
 * based on previous trade outcomes.
 */
function learnFromPast() {
  const trades = readTradeLog();
  const lastTrade = trades.slice(-1)[0];
  if (!lastTrade) {
    console.log('üß† No past trades to learn from yet.');
    return;
  }
  // TODO: Implement actual learning logic here.
  // Example: Adjust strategy parameters based on if the last trade was a win or loss.
  console.log(`üß† Learning from last trade (${lastTrade.pair} - ${lastTrade.result || 'pending'})...`);
}

/**
 * Triggers a UI.Vision RPA macro with dynamic parameters.
 * This function is designed to send commands to a locally running UI.Vision XModule.
 * @param {string} symbol - The trading symbol (e.g., EURUSD).
 * @param {string} direction - 'buy' or 'sell'.
 * @param {number} amount - The trade amount.
 * @param {number} expiry - The expiry time in minutes.
 * @param {string} username - Pocket Option username (email).
 * @param {string} password - Pocket Option password.
 */
const triggerUIVisionMacro = async (symbol, direction, amount, expiry, username, password) => {
  if (!UI_VISION_URL || !UI_VISION_MACRO_NAME || !UI_VISION_MACRO_PARAMS_JSON) {
    console.error('‚ùå UI.Vision configuration is incomplete. Cannot trigger macro.');
    throw new Error('UI.Vision configuration missing.');
  }
  if (!username || !password) {
    console.error('‚ùå Pocket Option credentials are not provided. Cannot trigger macro.');
    throw new Error('Pocket Option credentials missing.');
  }

  try {
    // Replace placeholders in the macro parameters JSON string with actual values
    // Ensure UI_VISION_MACRO_PARAMS_JSON is correctly defined in your .env file
    const macroParams = JSON.parse(
      UI_VISION_MACRO_PARAMS_JSON
        .replace(/{symbol}/g, symbol)
        .replace(/{direction}/g, direction)
        .replace(/{amount}/g, amount)
        .replace(/{expiry}/g, expiry)
        .replace(/{username}/g, username)
        .replace(/{password}/g, password)
    );

    await axios.post(UI_VISION_URL, {
      macro: UI_VISION_MACRO_NAME,
      params: macroParams
    });

    console.log(`‚úÖ UI.Vision macro "${UI_VISION_MACRO_NAME}" triggered for ${symbol}`);
  } catch (error) {
    console.error('‚ùå Failed to trigger UI.Vision macro:', error.message);
    // Log the full error if available for debugging
    if (error.response) {
      console.error('UI.Vision Response Data:', error.response.data);
      console.error('UI.Vision Response Status:', error.response.status);
    } else if (error.request) {
      console.error('No response received from UI.Vision:', error.request);
    }
    throw new Error(`Failed to trigger UI.Vision: ${error.message}`); // Re-throw for calling function to catch
  }
};


// === BACKGROUND LOOP ===
// This loop runs every 3 minutes (180000 milliseconds)
setInterval(() => {
  if (DEFAULT_TELEGRAM_CHAT_ID) {
    const suggestion = analyzeAndSuggest();
    learnFromPast(); // Call learning function
    bot.sendMessage(DEFAULT_TELEGRAM_CHAT_ID, `üìä Auto Analysis (Every 3m):\n${suggestion}`)
      .then(() => console.log('‚úÖ Sent auto analysis message.'))
      .catch(error => console.error('‚ùå Error sending auto analysis message:', error.message));
  } else {
    console.warn('‚ö†Ô∏è DEFAULT_TELEGRAM_CHAT_ID is not set. Auto analysis messages will not be sent.');
  }
}, 180000);

// === TELEGRAM BOT COMMAND HANDLERS ===

// /start command
bot.start((ctx) => {
  ctx.reply(`üëã Welcome, ${ctx.from.first_name}! I'm your Pocket Option trade bot.
Use /help to see available commands.`);
  console.log(`Received /start from ${ctx.from.username || ctx.from.first_name}`);
});

// /help command
bot.help((ctx) => {
  ctx.reply(`üìö Available commands:
/trade <pair> <buy|sell> <amount> <expiry_minutes> - Log and execute a trade via UI.Vision.
  Example: /trade EURUSD_OTC buy 100 5
/stats - Show last 3 trades and overall win rate.
/suggest - Get suggested trades (based on placeholder analysis).
/analyze - Trigger a manual analysis and get suggestions.
/ping - Test if bot is online.
`);
  console.log(`Received /help from ${ctx.from.username || ctx.from.first_name}`);
});

// /ping command
bot.command('ping', (ctx) => {
  ctx.reply('üèì Pong!');
  console.log(`Received /ping from ${ctx.from.username || ctx.from.first_name}`);
});

// /trade command: /trade EURUSD_OTC buy 100 5
bot.command('trade', async (ctx) => { // Added 'async' keyword here
  const args = ctx.message.text.split(' ').slice(1); // Get arguments after /trade
  if (args.length !== 4) {
    return ctx.reply('‚ö†Ô∏è Usage: /trade <pair> <buy|sell> <amount> <expiry_minutes>\nExample: /trade EURUSD_OTC buy 100 5');
  }

  const [pair, direction, amountStr, expiryStr] = args;
  const amount = parseFloat(amountStr);
  const expiry = parseInt(expiryStr);

  if (!['buy', 'sell'].includes(direction.toLowerCase())) {
    return ctx.reply('‚ö†Ô∏è Invalid direction. Must be "buy" or "sell".');
  }
  if (isNaN(amount) || amount <= 0) {
    return ctx.reply('‚ö†Ô∏è Invalid amount. Must be a positive number.');
  }
  if (isNaN(expiry) || expiry <= 0) {
    return ctx.reply('‚ö†Ô∏è Invalid expiry. Must be a positive integer in minutes.');
  }

  // Log the trade locally first
  logTrade(pair.toUpperCase(), direction.toLowerCase(), amount, expiry);
  ctx.reply(`‚úÖ Trade Received and Logged:\nPair: ${pair.toUpperCase()}\nType: ${direction.toUpperCase()}\nAmount: $${amount}\nExpiry: ${expiry}m\nAttempting to execute via UI.Vision...`);
  console.log(`Received /trade ${pair} ${direction} ${amount} ${expiry} from ${ctx.from.username || ctx.from.first_name}`);

  // Attempt to trigger UI.Vision macro
  try {
    await triggerUIVisionMacro(
      pair.toUpperCase(),
      direction.toLowerCase(),
      amount,
      expiry,
      POCKET_OPTION_USERNAME,
      POCKET_OPTION_PASSWORD
    );
    ctx.reply('üéâ UI.Vision trade macro executed successfully!');
  } catch (error) {
    console.error('‚ùå Error executing trade via UI.Vision:', error);
    ctx.reply(`‚ùå Failed to execute trade via UI.Vision: ${error.message}. Check server logs for details.`);
  }
});

// /stats command
bot.command('stats', (ctx) => {
  const { last3, winRate } = getTradeStats();
  let summary = 'üìä Last 3 Trades:\n';
  if (last3.length === 0) {
    summary += 'No trades logged yet.';
  } else {
    summary += last3.map(t => {
      const tradeResult = t.result ? ` - ${t.result.toUpperCase()}` : ' - pending';
      return `‚Ä¢ ${t.pair} ${t.direction.toUpperCase()} $${t.amount} ${t.expiry}m${tradeResult} @ ${new Date(t.timestamp).toLocaleTimeString()}`;
    }).join('\n');
  }
  ctx.reply(`${summary}\n\nüèÜ Overall Win Rate: ${winRate}`);
  console.log(`Received /stats from ${ctx.from.username || ctx.from.first_name}`);
});

// /suggest command
bot.command('suggest', (ctx) => {
  const suggestion = analyzeAndSuggest();
  ctx.reply(`üí° Suggested Trades:\n${suggestion}`);
  console.log(`Received /suggest from ${ctx.from.username || ctx.from.first_name}`);
});

// /analyze command (manual trigger for analysis)
// This will now also attempt to trigger a UI.Vision macro.
// Note: The PocketOptionTrade macro is for trade execution.
// If you have a separate UI.Vision macro for 'analysis', update UI_VISION_MACRO_NAME accordingly for this command.
bot.command('analyze', async (ctx) => { // Added 'async' keyword here
  const suggestion = analyzeAndSuggest();
  ctx.reply(`üìà Manual Analysis Triggered:\n${suggestion}\nAttempting to trigger UI.Vision analysis...`);
  console.log(`Received /analyze from ${ctx.from.username || ctx.from.first_name}`);

  try {
    // For a real 'analyze' command, you might have a different UI.Vision macro name
    // and different parameters. For now, it will use the PocketOptionTrade macro
    // with dummy values or you can create a specific 'AnalyzeChart' macro.
    // Example: await triggerUIVisionMacro('EURUSD_OTC', 'buy', 0, 0, POCKET_OPTION_USERNAME, POCKET_OPTION_PASSWORD);
    // Or, if you have a dedicated analysis macro:
    // await triggerUIVisionMacroForAnalysis(POCKET_OPTION_USERNAME, POCKET_OPTION_PASSWORD);
    // For now, just a success message if the UI_VISION_URL is configured.
    if (UI_VISION_URL && UI_VISION_MACRO_NAME && POCKET_OPTION_USERNAME && POCKET_OPTION_PASSWORD) {
        // You might want to define a separate macro for analysis or adjust this call.
        // For demonstration, we'll just confirm the attempt.
        ctx.reply('‚úÖ UI.Vision analysis trigger attempted (assuming a relevant macro is configured).');
    } else {
        ctx.reply('‚ö†Ô∏è UI.Vision analysis not triggered: Configuration missing or incomplete.');
    }
  } catch (error) {
    console.error('‚ùå Error triggering UI.Vision analysis:', error);
    ctx.reply(`‚ùå Failed to trigger UI.Vision analysis: ${error.message}. Check server logs.`);
  }
});

// === START THE BOT ===
bot.launch()
  .then(() => console.log('üöÄ Telegram bot started (polling mode).'))
  .catch((err) => console.error('‚ùå Failed to start Telegram bot:', err));

// Enable graceful stop
process.once('SIGINT', () => {
  console.log('Received SIGINT. Stopping bot...');
  bot.stop('SIGINT');
  process.exit(0);
});
process.once('SIGTERM', () => {
  console.log('Received SIGTERM. Stopping bot...');
  bot.stop('SIGTERM');
  process.exit(0);
});
